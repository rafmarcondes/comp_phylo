"""
Exercise 5 - Creating a continuous-time Markov chain class
@author: jembrown

The point of this exercise is to define a new class, called ctmc (for continuous-
time Markov chain), that contains all necessary information and methods related
to such a chain, running simulations of these chains, calculating summaries of
chains, calculating probabilities of specific character histories, 
calculating marginal probabilities of starting and ending states, and estimating
branch lengths from the marginal probabilities using maximum likelihood.

This exercise is roughly divided into three steps:

(a) Define the ctmc class and its __init__ method. In the __init__, set up the
following variables associated with instances of ctmc:

- time (or branch length)
- state space (for our purposes this will usually be the 4 nucleotides)
- stationary (or equilibrium) frequencies of the states
- an 'R' vector defining the relative propensity for diff't changes
- a 'Q' matrix used to define rates of changes and calc. probabilities
- the number of simulations (or independent chains or sites)
- lists of event times generated by the simulations
- lists of event states generated by the simulations
- a list of starting states across simulations (optional - could also be the
  first element of the event states lists)
- a list of character history probabilities
- a list of marginal probabilities (using just starting and ending states,
  along with the branch length)
  
NOTES: In the usual method for defining GTR-class Q-matrices in phylogenetics,
the equilibrium frequencies and R-vector rates are used to define elements of
the Q-matrix. You can initialize them in any way you like, but it would be a 
good idea to write a function to make sure they are all consistent and to 
update elements of the Q-matrix when equil. frequencies or R-rates change.
  
(b) Define a method for simulating character histories using the Q-matrix.

(c) Define a method that estimates branch lengths from marginal probabilities
using maximum likelihood. Use a 'site-independent' model, where the marginal
probability across the entire data set (i.e., across all simulations jointly)
is simply the product of the site probabilities.
"""

# Import statements


def sdd(events,probs):
    """This function is named after "Sample from Discrete Distribution". It takes as arguments two lists,
    'events' and 'probs', in which 'probs' contains floats 
    representing probabilities associated, respectively, with the itens in 'events', that can be strings, 
    floats, ints, or any data type. The two lists must be of same size."""
    
    import random
    nprobs=[x*1000 for x in probs] #so, here i multiply each float in 'probs' by 1000 and store the products in 'nprobs'
    newlist=[]
    for a in range(len(events)) : #then, in this loop, i create a list (newlist), in which each event appears 1000*its probability times
        b=nprobs[a]
        b=int(b)
        for c in range(b) :
            newlist.append(events[a]) 
    return (random.choice(newlist)) #and finally, i ramdonly sample 



class ctmc(object):
    """         
    A class defining a continuous-time Markov chain (CTMC)
    """
          
    def __init__(self,q,staspa,v,simulations,times,nsites,starts,finals,sitemargprobs,seqmargprob):
        self.q=q 
        self.staspa=staspa
        self.v=v
        self.simulations=simulations
        self.times=times
        self.nsites=nsites
        self.starts=starts #starting states
        self.finals=finals #final states
        self.sitemargprobs=sitemargprobs
        self.seqmargprob=seqmargprob
        



    def branchsimulate(self, parentnode=None):
        for n in range(self.nsites) :
            """IMPORTANT:rows and columns in the q-matrix MUST be in the order ACGT
            IMPORTANT2: the q-matrix should be a numpy matrix object, a 'list of lists' won't work
            IMPORTANT3: this function is dependendt on my discrete sampling function, 'sdd', pasted above
            'parentnode' argument is to be used in the context of simulations on trees"""
            
            """ This method has no return statement. Rather, it simply updates 
            the ctmc attributes 'simulations', 'times', 'starts' and 'finals'"""
            import random
            statup=tuple(self.staspa) 
            """during the function, i'll have to remove elements from the 'states' list, but later reset the list 
            to its original composition. i'll use the 'statup' tuple as a 'backup'to do that"""
            chain=[]
            times=[]
            elapsedtime=0 #initialize a variable for the elapsed time
            if parentnode is None: 
                currstate=random.choice(self.staspa) #CHANGE this TO SAMPLE INITIAL STATE FROM STATIONARY PROBS
            else :
                currstate=parentnode.markov.finals[n]      
            chain.append(currstate)
            wt=0 #initialize the waiting time variable
            while elapsedtime<self.v :
                """this series of if statements chooses the appropriate lambda (rate of the 
                exponential distribution), given the currente state"""
                if currstate=='a' :
                    lambd=-(self.q.item(0,0))
                if currstate=='c' :
                    lambd=-(self.q.item(1,1))
                if currstate=='g' :
                    lambd=-(self.q.item(2,2))
                if currstate=='t' :
                    lambd=-(self.q.item(3,3))
                wt=random.expovariate(lambd) #use the appropriate lambda to draw a waiting time
                elapsedtime+=wt
                if elapsedtime>self.v : 
                    """if elapsedtime will exceed v with the addition of the last wt, 
                    then undo its addition to elapsed time and break the while loop, because v has been reached"""
                    elapsedtime-=wt
                    break
                times.append(wt)
                """this series of if/elif statements draws the next state"""       
                if currstate=='a' :
                    self.staspa.remove('a') #in order to not draw the same state as the current one
                    currstate=sdd(self.staspa,[self.q.item(1)/-self.q.item(0),self.q.item(2)/-self.q.item(0),self.q.item(3)/-self.q.item(0)])
                elif currstate=='c' :
                    self.staspa.remove('c')
                    currstate=sdd(self.staspa,[self.q.item(4)/-self.q.item(5),self.q.item(6)/-self.q.item(5),self.q.item(7)/-self.q.item(5)])
                elif currstate=='g' :
                    self.staspa.remove('g')
                    currstate=sdd(self.staspa,[self.q.item(8)/-self.q.item(10),self.q.item(9)/-self.q.item(10),self.q.item(11)/-self.q.item(11)])
                elif currstate=='t' :
                    self.staspa.remove('t')
                    currstate=sdd(self.staspa,[self.q.item(12)/-self.q.item(15),self.q.item(13)/-self.q.item(15),self.q.item(14)/-self.q.item(15)])
                chain.append(currstate)
                self.staspa=list(statup) #reset the 'states' list to its original composition
            times.append(self.v-elapsedtime) 
            """append to the times list the difference between the elapsed time so far and v, so that the 
            final elapsedtime, or sum(times), equals v"""
            self.starts+=(chain[0])
            self.finals+=(chain[-1])
            self.simulations.append(chain) #append the class attributes chains and times with the output of the simulations
            self.times.append(times)
    
    def margprobssites(self) :
        """outputs a list contining margprobs for each site in sequence"""
        sitemargprobs=[]
        import scipy
        pmatrix=scipy.linalg.expm(self.q*self.v)
        for i in range(self.nsites) :
            initial=self.starts[i]
            final=self.finals[i]
            iindex=self.staspa.index(initial)
            findex=self.staspa.index(final)
            mp=pmatrix[iindex,findex]
            sitemargprobs.append(mp)
        return sitemargprobs
        

        
    def margprobseq(self,v=None) :
        """margprob of whole seq, calculated by multiplying margprobs for each site.
                
        The keyword argument v is supposed to be used in situations where i don't want to use the self.v associated
        with the object and used to run the simulation, such as in calculating ML (method below), where the v used will
        be vCurr, vUp and vDown"""  
        if v is None :    
            sitemargprobs=[]
            for i in range(self.nsites) :
                initial=self.starts[i]
                final=self.finals[i]
                import scipy    
                pmatrix=scipy.linalg.expm(self.q*self.v)
                iindex=self.staspa.index(initial)
                findex=self.staspa.index(final)
                mp=pmatrix[iindex,findex]
                sitemargprobs.append(mp)
            seqmargprob=1
            for j in sitemargprobs:
                seqmargprob*=j
            return seqmargprob
        else:
            sitemargprobs=[]
            for i in range(self.nsites) :
                initial=self.starts[i]
                final=self.finals[i]
                import scipy    
                pmatrix=scipy.linalg.expm(self.q*v)
                iindex=self.staspa.index(initial)
                findex=self.staspa.index(final)
                mp=pmatrix[iindex,findex]
                sitemargprobs.append(mp)
            seqmargprob=1
            for j in sitemargprobs:
                seqmargprob*=j
            return seqmargprob
                

    def mlv(self,vStart,diff): 
        """vStart MUST be different from 0"""
        vCurr=vStart
        while diff>0.0001 :
            """CHANGE THE ABOVE TO BE AN ARGUMENT"""
            likeCurr=self.margprobseq(v=vCurr)
            vUp=vCurr+diff
            vDown=vCurr-diff
            if (vDown < 0):
                vDown = 0
            likeUp=self.margprobseq(v=vUp)
            likeDown=self.margprobseq(v=vDown)
            if likeDown>likeCurr :
                vCurr=vDown
                vUp=vCurr+diff
                vDown=vCurr-diff
            elif likeUp>likeCurr :
                vCurr=vUp
                vUp=vCurr+diff
                vDown=vCurr-diff
            else :
                diff=(diff/2.0)            
        return vCurr             
    


""""
defined class above
testing it below
"""



import numpy
myq=numpy.matrix('-1.916 0.541 0.787 0.588; 0.148 -1.069 0.415 0.506; 0.286 0.170 -0.591 0.135; 0.525 0.236 0.594 -1.355') 
mymark=ctmc(staspa=['a','c','g','t'],q=myq,v=0.5,simulations=[],times=[],nsites=30,starts='',finals='',sitemargprobs=[],seqmargprob=1)

mymark.branchsimulate()

print(mymark.simulations)
print(mymark.times)

print(mymark.starts)
print(mymark.finals)

print(mymark.margprobssites())
print(mymark.margprobseq())

print(mymark.sitemargprobs)
print(mymark.seqmargprob)

print(mymark.mlv(vStart=0.2,diff=0.1))
